from datetime import tzinfo

from _typeshed import Incomplete
from icalendar import compat as compat
from icalendar.caselessdict import CaselessDict as CaselessDict
from icalendar.parser import Parameters as Parameters
from icalendar.parser import escape_char as escape_char
from icalendar.parser import tzid_from_dt as tzid_from_dt
from icalendar.parser import unescape_char as unescape_char
from icalendar.parser_tools import DEFAULT_ENCODING as DEFAULT_ENCODING
from icalendar.parser_tools import SEQUENCE_TYPES as SEQUENCE_TYPES
from icalendar.parser_tools import to_unicode as to_unicode
from icalendar.windows_to_olson import WINDOWS_TO_OLSON as WINDOWS_TO_OLSON

DATE_PART: str
TIME_PART: str
DATETIME_PART: Incomplete
WEEKS_PART: str
DURATION_REGEX: Incomplete
WEEKDAY_RULE: Incomplete
ZERO: Incomplete
HOUR: Incomplete
STDOFFSET: Incomplete
DSTOFFSET: Incomplete
DSTOFFSET = STDOFFSET
DSTDIFF: Incomplete

class FixedOffset(tzinfo):
    def __init__(self, offset, name) -> None: ...
    def utcoffset(self, dt): ...
    def tzname(self, dt): ...
    def dst(self, dt): ...

class LocalTimezone(tzinfo):
    def utcoffset(self, dt): ...
    def dst(self, dt): ...
    def tzname(self, dt): ...

class vBinary:
    obj: Incomplete
    params: Incomplete
    def __init__(self, obj) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vBoolean(int):
    BOOL_MAP: Incomplete
    params: Incomplete
    def __new__(cls, *args, **kwargs): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vCalAddress(compat.unicode_type):
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vFloat(float):
    params: Incomplete
    def __new__(cls, *args, **kwargs): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vInt(int):
    params: Incomplete
    def __new__(cls, *args, **kwargs): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vDDDLists:
    params: Incomplete
    dts: Incomplete
    def __init__(self, dt_list) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical, timezone: Incomplete | None = ...): ...

class vCategory:
    cats: Incomplete
    def __init__(self, c_list) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical, timezone: Incomplete | None = ...): ...

class vDDDTypes:
    params: Incomplete
    dt: Incomplete
    def __init__(self, dt) -> None: ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical, timezone: Incomplete | None = ...): ...

class vDate:
    dt: Incomplete
    params: Incomplete
    def __init__(self, dt) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vDatetime:
    dt: Incomplete
    params: Incomplete
    def __init__(self, dt) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical, timezone: Incomplete | None = ...): ...

class vDuration:
    td: Incomplete
    params: Incomplete
    def __init__(self, td) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vPeriod:
    params: Incomplete
    start: Incomplete
    end: Incomplete
    by_duration: Incomplete
    duration: Incomplete
    def __init__(self, per) -> None: ...
    def __cmp__(self, other): ...
    def overlaps(self, other): ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vWeekday(compat.unicode_type):
    week_days: Incomplete
    relative: Incomplete
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vFrequency(compat.unicode_type):
    frequencies: Incomplete
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vRecur(CaselessDict):
    frequencies: Incomplete
    canonical_order: Incomplete
    types: Incomplete
    params: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def to_ical(self): ...
    @classmethod
    def parse_type(cls, key, values): ...
    @classmethod
    def from_ical(cls, ical): ...

class vText(compat.unicode_type):
    encoding: Incomplete
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vTime:
    dt: Incomplete
    params: Incomplete
    def __init__(self, *args) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vUri(compat.unicode_type):
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vGeo:
    latitude: Incomplete
    longitude: Incomplete
    params: Incomplete
    def __init__(self, geo) -> None: ...
    def to_ical(self): ...
    @staticmethod
    def from_ical(ical): ...

class vUTCOffset:
    ignore_exceptions: bool
    td: Incomplete
    params: Incomplete
    def __init__(self, td) -> None: ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class vInline(compat.unicode_type):
    params: Incomplete
    def __new__(cls, value, encoding=...): ...
    def to_ical(self): ...
    @classmethod
    def from_ical(cls, ical): ...

class TypesFactory(CaselessDict):
    all_types: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    types_map: Incomplete
    def for_property(self, name): ...
    def to_ical(self, name, value): ...
    def from_ical(self, name, value): ...

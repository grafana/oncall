from rest_framework.throttling import SimpleRateThrottle


class CustomRateScopedThrottler(SimpleRateThrottle):
    """
    Abstract class to create throttlers with custom amount of seconds and custom scope.
    The unique cache key will be generated by concatenating the
    user id of the request, and the scope from get_scope() method.

    Should not be used directly.
    """

    def __init__(self):
        self.scope = self.get_scope()
        self.num_requests, self.duration = self.get_throttle_limits()

    def get_throttle_limits(self):
        """
        :return tuple requests/seconds
        """
        raise NotImplementedError

    def get_scope(self):
        """
        :return ratelimit scope
        """
        raise NotImplementedError

    def allow_request(self, request, view):
        """
        Overriden allow_request method.
        The difference is that overriden method doesn't check rate property.
        """

        self.key = self.get_cache_key(request, view)
        if self.key is None:
            return True

        self.history = self.cache.get(self.key, [])
        self.now = self.timer()

        # Drop any requests from the history which have now passed the
        # throttle duration
        while self.history and self.history[-1] <= self.now - self.duration:
            self.history.pop()
        if len(self.history) >= self.num_requests:
            return self.throttle_failure()
        return self.throttle_success()

    def get_cache_key(self, request, view):
        if request.user.is_authenticated:
            ident = request.user.pk
        else:
            ident = self.get_ident(request)

        return self.cache_format % {"scope": self.scope, "ident": ident}
